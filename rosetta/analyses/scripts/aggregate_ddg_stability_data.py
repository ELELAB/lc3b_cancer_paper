#!/usr/bin/env python
# -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-

import argparse
import re
import pandas as pd

def parse_ddg_stability_output(infile):
    """Parse the output file generated by the 
    analyze_ddg_binding.py script."""
    
    return pd.read_csv(infile, \
                       sep = ",", \
                       header = 0, \
                       index_col = 0)


def aggregate_saturation_scan(dfs):
    """Aggregate dataframes generated from the outputs
    of a saturation mutagenesis scan.
    """

    multiseries = []
    for df in dfs:
        # assuming each file contains the saturation
        # mutagenesis for one and only one position
        series_ddg = df["ddg"]
        # wild-type residue is in the first position of
        # each mutation name (i.e. D19A)
        wtres = series_ddg.index[0][:-1]
        # mutated residues are at the last position of
        # each mutation name
        mutations = [mut[-1] for mut in series_ddg.index]
        series_ddg.index = mutations
        series_ddg.name = wtres
        multiseries.append(series_ddg)
    # each mutated position will be a row of the dataframe 
    # (bind them column-wise and then transpose the dataframe)
    df = pd.concat(objs = multiseries, axis = 1).transpose()
    # add a column containing the residue numbers
    df["sortcol"] = \
        [int(re.search(r"\d+", name).group()) \
         for name in df.index]
    # sort the mutations by residue number
    df.sort_values(by = "sortcol", inplace = True)
    # sort the mutated residues alphabetically
    df.sort_index(axis = 1, inplace = True)
    # drop the sorting column
    df.drop("sortcol", axis = 1, inplace = True)
    # return the dataframe
    return df


def aggregate_single_mutations(dfs):
    """Aggregate dataframes generated from the outputs
    of scans of single mutations.
    """

    multiseries = [df["ddg"] for df in dfs]
    df = pd.concat(objs = multiseries, axis = 0)
    df.columns = ["scores"]
    # add a column containing the residue numbers
    df["sortcol"] = \
        [int(re.search(r"\d+", name).group()) \
         for name in df.index]
    # sort the mutations by residue number
    df.sort_values(by = "sortcol", inplace = True)
    # sort the mutated residues alphabetically
    df.sort_index(axis = 1, inplace = True)
    # drop the sorting column
    df.drop("sortcol", axis = 1, inplace = True)
    # return the dataframe
    return df


def aggregate_multiple_systems(dfs, sysnames):
    """Aggregate dataframes generated from the outputs of scans
    including the same set of mutations for different systems.
    """

    multiseries = [df["ddg"] for df in dfs]
    df = pd.concat(objs = multiseries, axis = 1)
    # add a column containing the residue numbers
    df["sortcol"] = \
        [int(re.search(r"\d+", name).group()) \
         for name in df.index]
    # sort the mutations by residue number
    df.sort_values(by = "sortcol", inplace = True)
    # sort the mutated residues alphabetically
    df.sort_index(axis = 1, inplace = True)
    # drop the sorting column
    df.drop("sortcol", axis = 1, inplace = True)
    if sysnames is not None:
        df.columns = sysnames
    # return the dataframe
    return df


def aggregate_contributions(dfs, contributions):
    """Aggregate dataframes containing energy contributions.
    """

    contr_dfs = [df[contributions] for df in dfs]
    df = pd.concat(objs = contr_dfs, axis = 0)
    # add a column containing the residue numbers
    df["sortcol"] = \
        [int(re.search(r"\d+", name).group()) \
         for name in df.index]
    # sort the mutations by residue number
    df.sort_values(by = "sortcol", inplace = True)
    # sort the mutated residues alphabetically
    df.sort_index(axis = 0, inplace = True)
    # drop the sorting column
    df.drop("sortcol", axis = 1, inplace = True)
    return df


if __name__ == "__main__":

    # create an argument parser
    parser = argparse.ArgumentParser()
    
    # add arguments to the parser
    i_helpstr = "Input files."
    parser.add_argument("-i", \
                        dest = "infiles", \
                        type = str, \
                        required = True, \
                        nargs = "+", \
                        help = i_helpstr)
    
    o_helpstr = "Output file containing the dataframe."
    parser.add_argument("-o", \
                        dest = "outfile", \
                        type = str, \
                        required = True, \
                        help = o_helpstr)

    m_choices = \
        ["saturation_scan", "single_mutations", \
         "contributions", "multiple_systems"]
    m_helpstr = \
        "Output data mode. If 'saturation_scan', it will be a " \
        "2D matrix where rows represent sequence positions and " \
        "columns represent mutations. If 'single_mutations' or " \
        "'contributions' it will be a dataframe where each row " \
        "represents a single mutation for a position and columns " \
        "are either the total score or the single contributions. If " \
        "'multiple_systems', it is assumed that the same set of " \
        "mutations was run for multiple systems, and the output " \
        "will be a dataframe where rows represent the system and " \
        "columns represent the mutations."
    parser.add_argument("-m", "--mode", \
                        dest = "mode", \
                        type = str, \
                        choices = m_choices, \
                        required = True, \
                        help = m_helpstr)

    sysnames_helpstr = \
        "Names of the systems for which the same set of mutations " \
        "was performed. The order should correspond to that of the " \
        "input files. Only used when 'multiple_systems' is " \
        "passed to -m."
    parser.add_argument("--sysnames", \
                        dest = "sysnames", \
                        type = str, \
                        default = None, \
                        required = False, \
                        nargs = "+", 
                        help = sysnames_helpstr)

    score_function_helpstr = \
        "Scoring function used when running any Rosetta protocol. " \
        "Will be used only if --convert is supplied or " \
        "'contributions' is supplied to -m."
    parser.add_argument("--score-function", \
                        dest = "score_function", \
                        type = str, \
                        required = True, \
                        default = None, \
                        help = score_function_helpstr)

    convert_helpstr = \
        "Whether to convert REU values to kcal/mol using scoring " \
        "function-specific conversion factors."
    parser.add_argument("--convert", \
                        dest = "convert", \
                        action = "store_true", \
                        default = False, \
                        help = convert_helpstr)

    sep_default = ","
    sep_helpstr = \
        "Field separator in the output dataframe. Default is {:s}."
    parser.add_argument("--sep", \
                        dest = "sep", \
                        type = str, \
                        required = False, \
                        default = sep_default, \
                        help = sep_helpstr.format(sep_default))

    float_format_default = r"%3.2f"
    float_format_helpstr = \
        "Format for floating point numbers in the output dataframe. " \
        "Default is {:s}."
    parser.add_argument("--float-format", \
                        dest = "float_format", \
                        type = str, \
                        required = False, \
                        default = float_format_default, \
                        help = float_format_helpstr.format(\
                                float_format_default))

    # parse the arguments
    args = parser.parse_args()
    infiles = args.infiles
    outfile = args.outfile
    mode = args.mode
    sysnames = args.sysnames
    score_function = args.score_function
    convert = args.convert
    sep = args.sep
    float_format = args.float_format

    # available conversion factors for Rosetta scoring functions
    SCFUNC2CONVFACT = \
        {"talaris2014" : (1.0/1.84), \
         "ref2015" : (1.0/2.94)}

    # energy contributions in the cartesian_ddg output files
    SCFUNC2CONTRIBUTIONS = \
        {"talaris2014": \
            ["fa_atr", "fa_rep", "fa_sol", "fa_intra_rep", "fa_elec", \
             "hbond_sr_bb", "hbond_lr_bb", "hbond_bb_sc", "hbond_sc", \
             "dslf_fa13", "rama", "omega", "fa_dun", "p_aa_pp", \
             "yhh_planarity", "ref", "cart_bonded"], \
        "ref2015" : \
            ["fa_atr", "fa_rep", "fa_sol", "fa_intra_rep", "fa_elec", \
             "hbond_sr_bb", "hbond_lr_bb", "hbond_bb_sc", "hbond_sc", \
             "dslf_fa13", "rama_prepro", "omega", "fa_dun", "p_aa_pp", \
             "yhh_planarity", "ref", "cart_bonded", \
             "fa_intra_sol_xover4", "lk_ball_wtd"]}

    # generate the dataframes
    dfs = [parse_ddg_stability_output(infile) for infile in infiles]

    # convert the scores according to the scoring
    # function-specific rescaling factors
    if convert:
        dfs = [df*SCFUNC2CONVFACT[score_function] for df in dfs]

    # select the output data mode
    if mode == "saturation_scan":
        df = aggregate_saturation_scan(dfs = dfs)
    elif mode == "single_mutations":
        df = aggregate_single_mutations(dfs = dfs)
    elif mode == "multiple_systems":
        df = aggregate_multiple_systems(\
            dfs = dfs, \
            sysnames = sysnames)
    elif mode == "contributions":
        df = aggregate_contributions(\
            dfs = dfs, \
            contributions = SCFUNC2CONTRIBUTIONS[score_function])

    # save the final dataframe to the output file
    df.to_csv(outfile, \
              sep = sep, \
              float_format = float_format)
